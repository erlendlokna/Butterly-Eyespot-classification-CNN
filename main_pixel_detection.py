# -*- coding: utf-8 -*-
"""pixel_classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZLV6Y1m3QCqKT_avOFfDex5w4Sn6x3FS

Pixel classification
"""

import tensorflow as tf # used to access argmax function
from tensorflow import keras # for building Neural Networks
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import numpy as np

from keras.models import Sequential
from keras.preprocessing.image import ImageDataGenerator # For data augmentation
from keras.layers import BatchNormalization
from keras.layers import Conv2D, MaxPooling2D, Dense, Flatten
from keras.utils import normalize, to_categorical
from keras.layers import Dropout
from keras.optimizers import SGD, RMSprop
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, balanced_accuracy_score 
import PIL 

import image_augmentation as aug
import image_segmentation as seg
import models

X = np.load('data/Xtrain_Classification2.npy')
Y = np.load('data/Ytrain_Classification2.npy')


# Splitting and preparing data
split_size = 0.2
x_train, x_test, y_train, y_test = train_test_split(X, Y, test_size=split_size) 
image_train = np.array([np.reshape(l, (5, 5, 3)) for l in x_train])
image_test = np.array([np.reshape(l, (5, 5, 3)) for l in x_test])

#Balancing data:
image_train, y_train = aug.balance_set(image_train, y_train)

#normalising:
img_train = (image_train.astype('float32')) / 255.
img_test = (image_test.astype('float32')) / 255.

y_train_cat = to_categorical(y_train)
y_test_cat = to_categorical(y_test)

#visualizing data:
images = np.array([np.reshape(l, (5, 5, 3)) for l in x_train]) #just for plotting
classes = ['background', 'rings', 'white center']
for i in range(9):
    plt.subplot(330 + i + 1)
    k= int(np.random.uniform(0, len(images)))
    # plt.imshow(images[int(np.random.uniform(0, len(images)))])
    plt.imshow(images[k])
    plt.title(classes[y_train[k]])
    plt.axis('off')
    plt.savefig("figures/images.pdf")
    # print(Y_train[k])
plt.show()

#initialising CNN model:

from keras.callbacks import  EarlyStopping
early_stop = EarlyStopping(monitor='val_loss', patience=10, verbose=1)
callbacks_list = [early_stop]


print(img_train.shape, y_train_cat.shape)
print(img_test.shape, y_test_cat)

#initialising and training model
model = models.pixel_detection_model()

history = model.fit(img_train, y_train_cat, 
                    epochs=20, batch_size=64, 
                    validation_data=(img_test, y_test_cat), 
                    verbose=1, callbacks=callbacks_list)


loss = history.history['loss']
val_loss = history.history['val_loss']
epochs = range(1, len(loss) + 1)
plt.plot(epochs, loss, 'y', label='Training loss')
plt.plot(epochs, val_loss, 'r', label='Validation loss')
plt.title('Training and validation loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.savefig("figures/training.pdf")
plt.show()

# EVALUATION
from sklearn.metrics import classification_report, balanced_accuracy_score 

preds =  model.predict(img_test)
preds = np.array([np.argmax(d) for d in preds])

print('Balanced accuracy score: ', balanced_accuracy_score(y_test, preds))

print("Testing on a picture..")

pic = PIL.Image.open("data/some_test_images/Image0050_Cu1.tif")
pic = np.array(pic.getdata()).reshape(pic.size[0], pic.size[1], 3)

img = seg.segment_image(model, pic)

plt.imshow(img)
plt.axis('off')
plt.savefig("segmented.pdf")